{
  "name": "backbone.paginator",
  "version": "2.0.0",
  "description": "A pageable Backbone.Collection superset. Supports server-side/client-side/infinite pagination and sorting.",
  "main": "lib/backbone.paginator.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/backbone-paginator/backbone.paginator.git"
  },
  "keywords": [
    "backbone"
  ],
  "author": {
    "name": "Jimmy Yuen Ho Wong",
    "email": "wyuenho@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/backbone-paginator/backbone.paginator/issues"
  },
  "dependencies": {
    "underscore": "^1.5.0",
    "backbone": "^1.1.2"
  },
  "devDependencies": {
    "grunt-contrib-clean": "^0.4.1",
    "grunt-jsduck": "^0.1.4",
    "grunt-contrib-uglify": "^0.2.2",
    "grunt-cli": "^0.1.9",
    "grunt": "^0.4.1",
    "grunt-qunit-istanbul": "^0.1.3",
    "grunt-contrib-connect": "^0.3.0"
  },
  "scripts": {
    "test": "grunt qunit"
  },
  "readme": "backbone.paginator\n==================\n\n|travis-status|_\n\nA pageable, drop-in replacement for Backbone.Collection called\nBackbone.PageableCollection.\n\n\n.. contents:: Table of Contents\n   :backlinks: none\n\n\nMigrating from Backbone.Paginator 1.0\n-------------------------------------\n\nBackbone.Paginator 2.0 was originally called backbone-pageable, which in turn\nwas inspired by Backbone.Paginator < 1.0 by @addyosmani. The two project has\nmerged as of May 2014 and backbone-pageable has effectively become\nBackbone.Paginator 2.0. This guide describes some of the differences and\nsimilarities to ease migration.\n\nPackage Naming\n++++++++++++++\n\nBackbone.Paginator 2.0 will continue to use the backbone.paginator name for the\nfile, ``npm`` and ``bower`` packages. In addition, a new ``component`` package\nis also available, also inheriting the backbone.paginator name.\n\nModule Naming\n+++++++++++++\n\nThe module exported by the packages will still be called ``PageableCollection``\nto emphasize the function of this Backbone plugin as a ``Collection`` instead of\na ``View``.\n\nAPI Changes\n+++++++++++\n\n=================================== ======================================================================================\nBackbone.Paginator <= 1.0           Backbone.Paginator 2.0\n=================================== ======================================================================================\n``Backbone.Paginator``              ``Backbone.PageableCollection``\n``Backbone.Paginator.requestPager`` ``PageableCollection.extend({mode: \"server\" | \"infinite\"})``\n``Backbone.Paginator.clientPager``  ``PageableCollection.extend({mode: \"client\"})``\n``paginator_core``                  Override ``PageableCollection#sync`` or use ``PagableCollection.fetch({data: {...}})``\n``paginator_ui``                    ``state``\n``server_api``                      ``queryParams``\n``bootstrap()``                     ``new Backbone.PageaableCollection([{...}, ...])``\n``parse()``                         ``parse()``, ``parseRecords()``, ``parseState()``, ``parseLinks()``\n``goTo()``                          ``getPage()``\n``prevPage()``, ``nextPage()``      ``getPreviousPage()``, ``getNextPage()``\n``howManyPer()``                    ``setPageSize()``\n``setSort()``                       ``setSorting()``\n``*Filter*()``                      N/A. Implement your own ``View`` or use ``underscore`` methods on ``fullCollection``\nDiacritic plugin                    N/A. See above\nN/A                                 ``getPageByOffSet()``\nN/A                                 ``hasPreviousPage()``, ``hasNextPage()``\nN/A                                 ``switchMode()``\n=================================== ======================================================================================\n\n\nAdvantages\n----------\n\nSupports client-side and server-side operations\n  You can initialize ``Backbone.PageableCollection`` to paginate and/or sort on\n  the client-side, server-side or both.\nInfinite paging\n  Many public APIs like `Github <http://developer.github.com/v3/#pagination>`_\n  or `Facebook\n  <https://developers.facebook.com/docs/reference/api/pagination/>`_ support\n  infinite paging, ``Backbone.PageableCollection`` can handle them easily.\nComes with reasonable defaults\n  Server API parameters preconfigured to work with most Rails RESTful APIs by\n  default.\nWorks well with existing server-side APIs\n  Query parameter mappings are all configurable, and you can use either 0-based\n  or 1-based indices.\nBi-directional event handling\n  In client-mode, any changes done on one page is immediately reflected on the\n  others with the appropriate events propagated.\n100% compatible with existing code\n  ``Backbone.PageableCollection`` is a strict superset of\n  ``Backbone.Collection`` and passes its `test suite\n  <http://backbone-paginator.github.io/backbone.paginator/test/index.html>`_.\nWell tested\n  Comes with 100s of tests in addition to the ``Backbone.Collection`` test\n  suite.\nWell documented\n  Use cases and functionality are thoroughly documented.\nNo surprising behavior\n  ``Backbone.PageableCollection`` performs internal state sanity checks at\n  appropriate times, so it is next to impossible to get into a weird state.\nLight-weight\n  The library is only 4.2KB minified and gzipped.\n\n\nPlayable Demos\n--------------\n\nThe following examples utilizes `Backgrid.js\n<http://backgridjs.com>`_ to render the collections.\n\n- `Server Mode <http://backbone-paginator.github.io/backbone.paginator/examples/server-mode.html>`_\n- `Client Mode <http://backbone-paginator.github.io/backbone.paginator/examples/client-mode.html>`_\n- `Infinite Mode <http://backbone-paginator.github.io/backbone.paginator/examples/infinite-mode.html>`_\n\n\nInstallation\n------------\n\nInstalling from Node.js\n+++++++++++++++++++++++\n\n.. code-block:: bash\n\n  npm install backbone.paginator\n\n\nInstalling from Bower\n+++++++++++++++++++++\n\n.. code-block:: bash\n\n  bower install backbone.paginator\n\n\nBrowser\n+++++++\n\n.. code-block:: html\n\n  <script src=\"underscore.js\"></script>\n  <script src=\"backbone.js\"></script>\n  <script src=\"backbone.paginator.js\"></script>\n\n\nGetting to the Backbone.PageableCollection Class from Node.js and AMD\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n.. code-block:: javascript\n\n  var PageableCollection = require(\"backbone.paginator\");\n\n\nGetting to the Backbone.PageableCollection Class in the Browser\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n.. code-block:: javascript\n\n  var PageableCollection = Backbone.PageableCollection;\n\n\nIntroduction\n------------\n\nLike Backbone.Collection, you can provide a URL endpoint, configure your initial\npagination state and server API mapping by extending\n``Backbone.PageableCollection``:\n\n.. code-block:: javascript\n\n  var Book = Backbone.Model.extend({});\n\n  var Books = Backbone.PageableCollection.extend({\n    model: Book,\n    url: \"api.mybookstore.com/books\",\n\n    // Any `state` or `queryParam` you override in a subclass will be merged with\n    // the defaults in `Backbone.PageableCollection` 's prototype.\n    state: {\n\n      // You can use 0-based or 1-based indices, the default is 1-based.\n      // You can set to 0-based by setting ``firstPage`` to 0.\n      firstPage: 0,\n\n      // Set this to the initial page index if different from `firstPage`. Can\n      // also be 0-based or 1-based.\n      currentPage: 2,\n\n      // Required under server-mode\n      totalRecords: 200\n    },\n\n    // You can configure the mapping from a `Backbone.PageableCollection#state`\n    // key to the query string parameters accepted by your server API.\n    queryParams: {\n\n      // `Backbone.PageableCollection#queryParams` converts to ruby's\n      // will_paginate keys by default.\n      currentPage: \"current_page\",\n      pageSize: \"page_size\"\n    }\n  });\n\n\nYou can initialize ``state`` and ``queryParams`` from the constructor too:\n\n.. code-block:: javascript\n\n   var Books = Backbone.PageableCollection.extend({\n     model: Book,\n     url:\"api.mybookstore.com/books\"\n   });\n\n   var books = new Books([], {\n\n     // All the `state` and `queryParams` key value pairs are merged with\n     // the defaults too.\n     state: {\n       firstPage: 0,\n       currentPage: 0\n     },\n\n     queryParams: {\n       currentPage: \"current_page\",\n       pageSize: \"page_size\"\n     }\n   });\n\n\nAdapting to a Server API\n++++++++++++++++++++++++\n\nTo adapt to an existing server API that do not use ``will_paginate`` keys, you\ncan configure the ``queryParams`` object hash to map ``state`` keys to the query\nparameters your server will accept. Those query parameters will be in the query\nstring of the URL used for fetching. You can also put extra items into\n``queryParams`` and they will be in the query string as is. Setting ``null`` as\nthe value of any mapping will remove it from the query string. Finally, the\nvalues in the ``queryParams`` can be either a literal value or a parameter-less\nfunction that returns a value.\n\nThis is a listing of the default ``state`` and ``queryParam`` values.\n\n============ ===== ============= ============================\n    ``state``                   ``queryParams``\n------------------ ------------------------------------------\nAttribute    Value Attribute     Value\n============ ===== ============= ============================\nfirstPage    1\nlastPage     null\ncurrentPage  null  currentPage   \"page\"\npageSize     25    pageSize      \"per_page\"\ntotalPages   null  totalPages    \"total_pages\"\ntotalRecords null  totalRecords  \"total_entries\"\nsortKey      null  sortKey       \"sort_by\"\norder        -1    order         \"order\"\n\\                  directions    { \"-1\": \"asc\", \"1\": \"desc\" }\n============ ===== ============= ============================\n\nYou can consult the `API documentation\n<http://backbone-paginator.github.io/backbone.paginator/#!/api/Backbone.PageableCollection>`_\nfor a detailed explaination of these fields.\n\nFetching Data and Managing States\n+++++++++++++++++++++++++++++++++\n\nYou can access the pageable collection's internal state by looking at the\n``state`` object attached to it. This state object, however, is generally\nread-only after initialization. There are various methods to help you manage\nthis state, you should use them instead of manually modifying it. For the\nunusual circumstances where you need to modify the ``state`` object directly, a\nsanity check will be performed at the next time you perform any\npagination-specific operations to ensure internal state consistency.\n\n================================ ===============================================\nMethod                           Use When\n================================ ===============================================\n``setPageSize``                  Changing the page size\n``setSorting``                   Changing the sorting\n``switchMode``                   Switching between modes\n``state``                        Need to read the internal state\n``get*Page``                     Need to go to a different page\n``hasPreviousPage, hasNextPage`` Check if paging backward or forward is possible\n================================ ===============================================\n\nIn addition to the above methods, you can also synchronize the state with the\nserver during a fetch. ``Backbone.PageableCollection`` overrides the default\n`Backbone.Collection#parse <http://backbonejs.org/#Collection-parse>`_ method to\nsupport an additional response data structure that contains an object hash of\npagination state. The following is a table of the response data structure\nformats ``Backbone.PageableCollection`` accepts.\n\n================= ========================================\nWithout State     With State\n================= ========================================\n``[{}, {}, ...]`` ``[{ pagination state }, [{}, {} ...]]``\n================= ========================================\n\nMost of the time, providing something like this in your response is sufficient\nfor updating the pagination state.\n\n``[{\"total_entries\": 100}, [{}, {}, ...]]``\n\nSince 1.1.7, customizing ``parse`` has been simplified and the default\nimplementation now delegates to two new methods - ``parseState`` and\n``parseRecords``. You are encouraged to override them instead of ``parse`` if it\nis not clear how to do so. For infinite mode, you should override ``parseLinks``\ninstead of ``parseState`` to return an object of links.\n\nSee the examples below or the `API\n<http://backbone-paginator.github.io/backbone.paginator/>`_ for details on\ncustomizing ``parseState``, ``parseRecords`` and ``parseLinks``.\n\nBootstrapping\n-------------\n\n``Backbone.PageableCollection`` is 100% compatible with ``Backbone.Collection``\n's interface, so you can bootstrap the models and supply a comparator to the\nconstructor just like you are used to:\n\n.. code-block:: javascript\n\n  // Bootstrap with just 1 page of data for server-mode, or all the pages for\n  // client-mode.\n  var books = new Books([\n    { name: \"A Tale of Two Cities\" },\n    { name: \"Lord of the Rings\" },\n    // ...\n  ], {\n    // Paginate and sort on the client side, default is `server`.\n    mode: \"client\",\n    // This will maintain the current page in the order the comparator defined\n    // on the client-side, regardless of modes.\n    comparator: function (model) { return model.get(\"name\"); }\n  });\n\n\nPagination\n----------\n\nServer-Mode\n+++++++++++\n\n``Backbone.Pagination`` defaults to server-mode, which means it only holds one\npage of data at a time. All of the ``get*page`` operations are done by\ndelegating to ``fetch``. They return a ``jqXHR`` in this mode.\n\n.. code-block:: javascript\n\n  books.getFirstPage();\n  books.getPreviousPage();\n  books.getNextPage();\n  books.getLastPage();\n\n  // All the `get*Page` methods under server-mode delegates to `fetch`, so you\n  // can attach a callback to the returned `jqXHR` objects' `done` event.\n  books.getPage(2).done(function () {\n    // do something ...\n  });\n\n\nAll of the ``get*Page`` methods accept the same options\n`Backbone.Collection#fetch <http://backbonejs.org/#Collection-fetch>`_ accepts\nunder server-mode.\n\n\nClient-Mode\n+++++++++++\n\nClient-mode is a very convenient mode for paginating a handful of pages entirely\non the client side without going through the network page-by-page. This mode is\nbest suited if you only have a small number of pages so sending all of the data\nto the client is not too time-consuming.\n\n.. code-block:: javascript\n\n  var books = new Books([\n    // Bootstrap all the records for all the pages here\n  ], { mode: \"client\" });\n\n\nAll of the ``get*Page`` methods reset the pageable collection's data to the models\nbelonging to the current page and return the collection itself instead of a\n``jqXHR``.\n\n.. code-block:: javascript\n\n  // You can immediately operate on the collection without waiting for jQuery to\n  // call your `done` callback.\n  var json = JSON.stringify(books.getLastPage());\n\n  // You can force a fetch in client-mode to get the most updated data if the\n  // collection has gone stale.\n  books.getFirstPage({ fetch: true });\n\n  // Do something interesting with books...\n\n\nInfinite-Mode\n+++++++++++++\n\nInfinite paging mode is a hybrid of server mode and client mode. Once\ninitialized and bootstrapped, paging backwards will be done on the client-side\nby default while paging forward will be done by fetching.\n\nAs before, you can make use of ``getFirstPage``, ``getPreviousPage``,\n``getNextPage``, and ``getLastPage`` for navigation under infinite-mode. If a\npage has been fetched, you can use ``getPage`` directly with the page number, an\nerror will be thrown if the page has not been fetched yet.\n\nBy default, ``Backbone.PageableCollection`` parses the response headers to find\nout what the ``first``, ``next`` and ``prev`` links are. The parsed links are\navailable in the ``links`` field.\n\n.. code-block:: javascript\n\n   var Issues = Backbone.PageableCollection.extend({\n     url: \"https://api.github.com/repos/documentclound/backbone/issues?state=closed\",\n     mode: \"infinite\"\n\n     // Initial pagination states\n     state: {\n       pageSize: 15,\n       sortKey: \"updated\",\n       order: 1\n     },\n\n     // You can remap the query parameters from ``state`` keys from the default\n     // to those your server supports. Setting ``null`` on queryParams removed them\n     // from being appended to the request URLs.\n     queryParams: {\n       totalPages: null,\n       totalRecords: null,\n       sortKey: \"sort\",\n       order: \"direction\",\n       directions: {\n         \"-1\": \"asc\",\n         \"1\": \"desc\"\n       }\n     }\n\n   });\n\n   var issues = new Issues();\n\n   issues.getFirstPage().done(function () {\n      // do something interesting...\n   });\n\nIf your server API does not return the links using the ``Link`` header like\n`Github <http://developer.github.com/v3/#pagination>`_ does, you can subclass\n``Backbone.PageableCollection`` to override the ``parseLinks`` methods to\nreturn a links object.\n\n.. code-block:: javascript\n\n   var FBComment = Backbone.Model.extend({});\n\n   var FBComments = Backbone.PageableCollection.extend({\n     model: FBComment,\n     url: \"https://graph.facebook.com/A_REALLY_LONG_FACEBOOK_OBJECT_ID\",\n     mode: \"infinite\",\n     // Set the indices to 0-based for Graph API.\n     state: {\n       firstPage: 0\n     },\n     queryParams: {\n       pageSize: \"limit\",\n       // Setting a parameter mapping value to null removes it from the query string\n       currentPage: null,\n       // Any extra query string parameters are sent as is, values can be functions,\n       // which will be bound to the pageable collection instance temporarily\n       // when called.\n       offset: function () { return this.state.currentPage * this.state.pageSize; }\n     },\n     // Return all the comments for this Facebook object\n     parseRecords: function (resp) {\n       return resp.comments.data;\n     },\n     // Facebook's `paging` object is in the exact format\n     // `Backbone.PageableCollection` accepts.\n     parseLinks: function (resp, xhr) {\n       return resp.comments.paging;\n     }\n   });\n\nTo act on the newly fetched models under infinite mode, you can listen to the\n``fullCollection`` reference's ``add`` event like you would under client mode,\nand render the newly fetched models accordingly.\n\n.. code-block:: javascript\n\n   var ToiletPaper = Backbone.View.extend({\n\n     events: {\n       \"scroll\": \"fetchSheets\"\n     },\n\n     initialize: function (options) {\n       this.listenTo(this.collection.fullCollection, \"add\", this.addSheet);\n     },\n\n     addSheet: function () {\n       // ...\n     },\n\n     fetchSheets: function () {\n       this.collection.getNextPage();\n     },\n\n     // ...\n\n   });\n\n   var wordsOfTheDay = new Backbone.PageableCollection({\n     mode: \"infinite\",\n     // url, initial state, etc...\n   });\n\n   var toiletPaper = new ToiletPaper({collection: wordsOfTheDay});\n\n   $(\"#toilet-paper-dispenser\").append(toiletPaper.render().el);\n\n   wordsOfTheDay.fetch();\n\n\nNote:\n+++++\n\n**Don't** override ``parseState`` or send down a stateful list of records from\nthe server.\n\nUnder infinite mode, ``totalRecords`` will always equal to the number of models\ninside ``fullCollection`` i.e. ``fullCollection.length``. PagebleCollection will\nautomatically keep all the states consistent. Modifying the state during\ninfinite paging results in undefined behavior. As such, you shouldn't override\n``parseState`` and should only send down a stateless list of records as\ndescribed in `Fetching Data and Managing States`_.\n\n\nSorting\n-------\n\nSorting has been drastically simplified in the 1.0 release while retaining the\nfull power it had in older versions.\n\nThe main way to define a sorting for a pageable collection is to utilize the\n``setSorting`` method.  Given a ``sortKey`` and an ``order``, ``setSorting``\nsets ``state.sortKey`` and ``state.order`` to the given values. If ``order`` is\nnot given, ``state.order`` is assumed. By default a comparator is applied to the\nfull collection under client mode. Calling ``sort`` on the full collection will\nthen get the entire pageable collection sorted globally. When operating under\nserver or infinite mode, no comparator will be applied to the collection as\nsorting is assumed to be done on the server by default. Set ``options.full`` to\n``false`` to apply a comparator to the current page under any mode. To sort a\npageable collection under infinite mode on the client side, set ``options.side``\nto ``\"client\"`` will apply a comparator to the full collection.\n\nSetting ``sortKey`` to ``null`` removes the comparator from both the current\npage and the full collection.\n\n.. code-block:: javascript\n\n   var books = new Books([\n     ...\n   ], {\n     mode: \"client\"\n   });\n\n   // Sets a comparator on `#fullCollection` that sorts the title in ascending\n   // order\n   books.setSorting(\"title\");\n\n   // Don't forget to call `sort` just like you would on a `Backbone.Collection`\n   books.fullCollection.sort();\n\n   // Clears the comparator\n   books.setSorting(null);\n\n   // Sets a comparator on the current page that sorts the title in descending\n   // order\n   books.setSorting(\"title\", 1, {full: false})\n   books.sort();\n\n   books.switchMode(\"infinite\");\n\n   // Sorts the books collection under infinite paging mode on the client side\n   books.setSorting(\"title\", -1, {side: \"client\"});\n   books.fullCollection.sort();\n\n   books.switchMode(\"server\");\n\n   // Sets a comparator on the current page under server mode\n   books.setSorting(\"title\", {side: \"client\", full: false});\n   books.sort();\n\nManipulation\n------------\n\nThis is one of the areas where ``Backbone.PageableCollection`` truely shines. A\n``Backbone.PageableCollection`` instance not only can do everything a plain\n``Backbone.Collection`` can for the current page, in client-mode, it can also\nsynchronize changes and events across all of the pages. For example, you can add\nor remove a model from either a ``Backbone.PageableCollection`` instance, which\nis holding the current page, or the\n``Backbone.PageableCollection#fullCollection`` collection, which is a plain\n``Backbone.Collection`` holding the models for all of the pages, and the pages\nwill all update themselves to maintain within a page size. Any additions,\nremovals, resets, model attribute changes and synchronization actions are\ncommunicated between all the pages throught the two collections.\n\n.. code-block:: javascript\n\n   // The books collection is initialized to start at the first page.\n   var books = new Books([\n     // bootstrap with all of the models for all of the pages here\n   ], {\n     mode: \"client\"\n   });\n\n   // A book is added to the end of the current page, which will overflow to the\n   // next page and trigger an `add` event on `fullCollection`.\n   books.push({ name: \"The Great Gatsby\"});\n\n   books.fullCollection.at(books.state.currentPage - 1 * books.state.pageSize).get(\"name\");\n   >>> \"The Great Gatsby\"\n\n   // Add a new book to the beginning of the first page.\n   books.fullCollection.unshift({ name: \"Oliver Twist\" });\n   books.at(0).get(\"name\");\n   >>> \"Oliver Twist\"\n\n\nAPI Reference\n-------------\n\nSee `here <http://backbone-paginator.github.io/backbone.paginator/>`_.\n\n\nFAQ\n---\n\n#. Which package managers does backbone.paginator support?\n\n   bower, npm, CommonJS and AMD and Component.\n\n#. Why doesn't backbone.paginator support filtering?\n\n   Wheels should be reinvented only when they are crooked. backbone.paginator aims\n   to do one thing only and does it well, which is pagination and sorting. Besides,\n   since Backbone.PageableCollection is 100% compatible with Backbone.Collection,\n   you can do filtering fairly easily with Backbone's built-in support for\n   Underscore.js methods.\n\n\nLegal\n-----\n\nCopyright (c) 2013 Jimmy Yuen Ho Wong and contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n.. |travis-status| image:: https://travis-ci.org/backbone-paginator/backbone.paginator.png\n.. _travis-status: https://travis-ci.org/backbone-paginator/backbone.paginator\n",
  "readmeFilename": "README.rst",
  "homepage": "https://github.com/backbone-paginator/backbone.paginator",
  "_id": "backbone.paginator@2.0.0",
  "_shasum": "c0f67b90e706599b80584cd67274ef652be03a85",
  "_from": "backbone.paginator@",
  "_resolved": "https://registry.npmjs.org/backbone.paginator/-/backbone.paginator-2.0.0.tgz"
}
